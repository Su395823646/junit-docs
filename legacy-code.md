# 遗留代码单元测试(讲义)

> 遗留代码就是没有测试的代码。

## 为什么要对遗留代码增加单元测试？

1. 构建安全网，提升对代码质量的信心，一旦改出问题，单元测试就会失败
2. 减少人工回归测试的工作量
3. 提升代码的可读性和可维护性，降低代码维护的成本
4. 提升代码的可扩展性和灵活性，更容易响应需求的变化

## 遗留代码单元测试的难点

遗留代码在编写之初没有考虑测试，代码基本不具备可测试性。对于单元测试来说，最直接的感受就是被测方法不好测：

1. 被测方法代码太长太复杂，设计测试用例很困难
2. 被测方法代码依赖太多，准备测试环境很困难

要对遗留代码增加单元测试，绝大多数情况下需要对被测方法/类进行重构，降低代码的复杂度，增加一些注入点，将被测方法分而治之。

> 重构是指在不改变代码外部行为的同时对代码内部结构进行调整，达到简化和提升可读性的目的。

不同粒度下代码外部行为的表现形式是不同的：
1. 作为服务，对外暴露的是接口(与编程语言及其元素无关)
2. 作为库/模块。对外暴露的是公共类和公共方法

## 遗留代码单元测试的切入点

因为对依赖代码增加单元测试需要对代码进行重构，所以要特别谨慎：

1. 在对遗留代码的功能进行扩展和修改时(小规模重构)，对代码原有功能增加单元测试。
2. 从遗留代码中提取可重用的代码块时(逐步重构))，对提取的功能增加单元测试
3. 需要重构的代码有更粗粒度的测试(如组件测试、集成测试、接口测试)保护时，可以对遗留代码进行重构并增加单元测试。
4. 修改的成本远低于重写的成本时，可以进行重构并增加单元测试

## 编写遗留代码单元测试前的准备

1. 深入理解被测代码，了解其功能和实现，阅读文档、源码，找其他同时了解。
2. 熟悉IDE提供的常用的“安全”重构手法，和一些解依赖的方法。
3. 约上一个同事进行结对，在重构和编写测试时多一份保障，多一份思路。
4. 先增加一些粗粒度的成本较低的测试(如接口测试)进行保护。

## 编写遗留代码单元测试的步骤

第一步，**分解方法**：使用重构手法分解过长的被测方法  
第二步，**暴露接缝**：增加可以注入依赖的“接缝”  
第三步，**替换依赖**：使用重构手法降低依赖构造的复杂度  
第四步，**编写测试**：创建被测类(静态方法不用此步骤)并注入依赖，对提取出的方法编写单元测试  
第五步，**整洁代码**：对有测试保障的代码进一步重构，提升代码可读性。  

> 注，有些重构手法可以同时完成第一步和第二步

重复上述五个步骤，进行下一轮的重构和测试。

### 分解方法

1. 调整临时变量的位置

    **适用情况**：

        临时变量的声明和作用域之间还有其他代码逻辑，不适合作为同一个方法提取

2. 提取代码块

    **适用情况**：

        - 过于复杂的 if 条件
        - 用注释分割的代码逻辑
        - 条件分支
        - 循环体

3. 提取重复代码

    **适用情况**：

        同样或者相似的代码逻辑在同一个方法或者同一个类或子类中反复出现。

    **注意事项**：

        往往先要将重复代码中的不同部分通过**提取临时变量**和**提取方法**剥离出去。再使用提取方法将重复的代码逻辑提取成方法。


### 暴露接缝

> “接缝”是指在不修改代码的条件下，可以改变代码的行为一些“点”。每一个接缝都有一个激活点，在这里决定代码的行为。

#### 接缝分类　

1. 依赖注入，通过注入不同的依赖来改变行为，不同的依赖就是激活点
    * 参数注入
    * 构造方法注入
    * Setter注入
    * 框架注入(Spring)
2. 方法重写，通过重写父类的方法实现不同的逻辑，子类的实现就是激活点

#### 增加接缝

1. 提取方法参数

    **适用情况**：

        方法中使用的任何变量都可以使用该手法进行提取。

    **注意事项**：

        * 不能破坏原有方法的签名(一般不会直接修改原方法，而是增加一个新方法)
        * 方法参数过多导致代码可读性下降的坏味道(采用后面其它几种重构方法)

2. 增加带参数的构造方法

    **适用情况**：

        方法依赖的成员变量直接在无参数构造方法中初始化。且成员变量构造困难

2. 使用Getter访问成员变量

    **适用情况**：

        方法中直接使用了成员变量，但成员变量不能注入(如在无参构造函数中创建的final成员变量)。测试时可以构造子类重写Getter方法提供返回值。


3. 使用方法代替临时变量

    **适用情况**：

        方法中直接使用了临时变量，构造复杂无法替换(如单例或者静态工厂方法发)。可以将构造逻辑提取成一个成员方法，返回该临时变量。这样子类可以重写该方法提供不同的变量实现。


### 替换依赖

1. 直接构造依赖对象

    **适用情况**：

        简单 POJO 对象，有工厂方法，或者 Builder 方法。

2. 使用 Mock

    **适用情况**：

        非 final 类的对象。如果依赖的使接口或者抽象类，应该 mock 接口或抽象类，而不是 mock 具体实现类。


3. 提取接口或抽象类

    **适用情况**

        被测对象只是使用了依赖的一个或几个方法。可以提取一个接口或者抽象类，将这些方法作为接口方法或者抽象方法。

    **注意事项**

        原来方法的签名可能发生变化(参数类型有由具体类型变为接口或者抽象类)。

4. 增加包装类

    **适用情况**：

        静态工厂方法或者单例构造的依赖。创建一个新的包装类将该依赖包装起来。使方法依赖新的包装类。

    **注意事项**

        原来方法的签名可能发生变化(参数类型变为包装类型)。

### 编写测试

> 见《单元测试基础》


### 整洁代码

1. 重命名

    **适用情况**：
    
        新方法名、变量名不能表达准确的含义。

    **注意事项**：

        一般不修改原方法的名字(而是给原方法加上 @Deprecated)。

2. 增加注解

    **适用情况**：

        - 决定后续不再使用的方法加上 @Deprecated，并增加注释
        - 增加 ＠NonNull @Nullable 等提示非空或可空的参数


2. 移动方法

    **适用情况**：

        方法中的依赖几乎来自同一个外部对象，该方法和这个对象联系更紧密。

3. 使用方法对象代替方法

    **适用情况**

        方法依赖很多且只有该方法使用。

