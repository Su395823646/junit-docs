# 可测试性代码规范

软件的可测试性是指在一定的时间和成本前提下，进行测试设计、测试执行以此来发现软件的问题，以及发现故障并隔离、定位其故障的能力特性。简单的说，软件的可测试性就是一个计算机程序能够被测试的容易程度。

软件的可测试性和以下因素有关：

- **可控制性**：是否可以将被测组件的状态控制到如测试条件要求。
- **可观察性**：是否可以观察（中间或最后的）测试结果。
- **可隔离性**：被测组件是否可以隔离测试。
- **关注点分离**：被测组件是否有单一且清楚定义的任务。
- **易懂性**：被测组件是否有说明文档，或是本身可读性很高。
- **可自动化性**：被测组件是否可以自动测试。
- **异质性**：是否需要不同的测试方法及工具平行测试。

若软件的可测试性低，可能会造成测试工作的增加。

# 总则

可测试性代码规范是对基本代码规范的增强和补充，并非只遵守二者中的一个，应该遵守两者的合集。如果可测试性代码规范和基本代码规范出现冲突，请以要求更高更严格的一份规范为准。

代码可测试性低主要表现为：

- 被测对象及其依赖难以构造
- 被测对象的依赖无法设置
- 被测对象的测试结果难以获取
- 被测对象的逻辑复杂难以创造测试条件
- 被测对象依赖不可控的代码
- 被测对象行为描述不清难以理解
- 被测对象行为不确定具有随机性

如遇未在以下规则中覆盖的代码应避免出现上述情形，或者符合软件可测试性要求的因素（见上节）。

# 规则文档说明

一条规则最多包含以下四项说明。每项说明可能提供代码示例进行说明。

**应当**：必须遵照此建议编写代码。

```java
// 应当如此
public class ShouldAlwaysDoThis {}
```

**尽量**：尽可能按照次建议编写代码，如果你对背后原理十分清楚，又有其它限制，注释清楚后可以选择不遵守。

```java
// 尽量如此
public class DoThisIfPossible {}
```

**避免**：避免出现这样的代码。

```java
// 避免如此
public class DoNotDoThis {}
```

**原因**：这些建议背后的原因说明。

# 1. 控制反转

对于大多数的不可测代码来说，测试的首要难点在于依赖无法满足、测试条件无法满足。避免这个问题的关键在于被测代码要提供可以“提换”这些依赖的“接缝”，如方法参数、构造方法、子类可以重写的方法等，可以讲依赖进行注入。

## 1.1 不要在非静态内部类内引用外部类成员变量

**避免** 使用私有非静态内部类封装被测行为，以及引用外部类的成员变量。

```java
// 避免如此
public class OuterClass {
    private int outerField;

    private class InnerClass {
        int doCalculate() {
             // 引用外部成员变量
            return outerField * 5;
        }
    }
}
```

**尽量** 使用独立的类，增加成员变量并提供构造方法初始化。

```java
// 尽量如此
public class InnerClass {
    private int innerField;

    public InnerClass(int innerField) {
        this.innerField = innerField;
    }

    int doCalculate() {
        return innerField * 5;
    }
}

// 通过构造方法初始化
assertThat(new InnerCalss(someValue).doCalculate(), ...);
```

**原因** 内部类的被测行为不可见，无法验证；外部类构造复杂影响内部类测试；独立出来的类可以更方便编写独立的单元测试。

## 1.2 不要在非静态内部类内引用外部类成员方法

**避免** 使用私有非静态内部类封装被测行为，以及引用外部类的成员方法。

```java
// 避免如此
public class OuterClass {
    private int outerMethod() {...}

    private class InnerClass {
        int doCalculate() {
             // 引用外部成员方法
            return outerMethod() * 5;
        }
    }
}
```

**尽量** 使用独立的类，增加成员变量引用其他类的行为，并提供构造方法初始化成员变量。其他类的行为应该抽象成接口。

```java
// 尽量如此
// 依赖的外部类的方法抽取成接口
interface OuterInterface {
    public int outerMethod();
}

public class OuterClass implements OuterInterface {
    public int outerMethod() {...}
}

// 使用独立的类
public class InnerClass {
    private OuterInterface outerInterface;

    // 依赖抽象的接口
    public InnerClass(OuterInterface outerInterface) {
        this.outerInterface = outerInterface;
    }

    int doCalculate() {
        return outerInterface.outerMethod() * 5;
    }
}

// 在测试中使用Stub或者mock
assertThat(new InnerCalss(new OuterInterface(){
    public int outerMethod() {...}
}).doCalculate(), ...);
```

**原因** 内部类的被测行为不可见，无法验证；外部类构造复杂影响内部类测试，使用抽象接口解除对外部类的依赖；独立出来的类可以更方便编写独立的单元测试；使用抽象接口避免循环依赖。

## 1.3 提供带参数的构造方法

**避免** 类只有一个无参构造方法，且复杂的成员变量构造只放在这个无参构造方法中。

```java
//TODO
```

**应当** 提供带参数的构造方法，允许通过这些构造方法的参数传递依赖。可以重载多个构造方法满足不同需要。合理选择构造方法的可见性（至少是 package 可见）。

```java
//TODO
```

**原因** 成员变量如果只能在无参构造方法内初始化则没有办法进行替换。尤其是成员变量依赖无法构造时（引用依赖 Android 框架的单例时）将导致测试无法进行。

## 1.4 避免在成员变量声明时初始化

**避免** 复杂的成员变量只能在声明时初始化。

```java
//TODO
```

**应当** 在带参数的构造方法中对成员变量进行初始化。可以使用无参构造方法调用带参数的构造方法，并提供该变量的默认值。

```java
//TODO
```

**原因** 成员变量如果只能在声明时初始化则没有办法进行替换。尤其是成员变量构造复杂不可控时（引用依赖 Android 框架的单例时）将导致测试无法进行。

## 1.5 将依赖变成方法参数

**应当** 将方法中的构造复杂不可控的临时变量作为方法参数传入。可以保留原有的方法，使用临时变量的原来得值调用新的方法。

```java
//TODO
```

**原因** 临时变量初始化放在方法中则没有办法进行替换。尤其是成员变量构造复杂不可控时（引用依赖 Android 框架的单例时）将导致测试无法进行。

## 1.6 用 getter 代替单例变量

**尽量** 将代码逻辑中对构造复杂不可控的单例变量的引用，变成对 getter 方法的调用；用可见性为 protected 的 getter 方法包装单例的获取

```java
//TODO
```

**原因** 构造复杂不可控时（引用依赖 Android 框架的单例时）将导致测试无法进行。测试时可以集成被测类重写 getter 方法返回代替单例的值。

## 1.7 为控件设置稳定的 id 或 description

**应当** 为界面上的可以互动和呈现信息的控件设置稳定 id 或 description。界面布局的调整不应当修改 id 或 description。

**原因** 没有 id 或 description 将导致界面自动化测试定位控件的代码复杂，可读性差，浪费调试时间。id 或 description 将导致界面自动化测试稳定性差，难以维护，难以抽象。

## 1.8 遵循 id 和 description 规范

**应当** 建立 id 和 description 的命名规范。

**原因** 按照规范的约定就可以根据 id 或 description 确定对应的控件的作用，反之亦然，来提升界面自动化测试的开发效率。

## 1.9 将线程中的逻辑独立出来

## 1.10 对系统时间的依赖进行封装

## 1.11 将数据库操作抽象成接口

## 1.12 将文件操作抽象成接口

# 2. 降低复杂度

为复杂的代码创造特定的测试条件需要大量的代码，容易出错，写出来的测试代码也难以理解。复杂的代码也不利于对被测代码的理解。

## 2.1 避免嵌套条件语句

**避免** 条件语句中嵌套条件语句。

**应用** 将嵌套的条件语句提取成方法。

**原因** 要进行复杂的前置准备才能让代码在执行时进入某一条期望的分支路径。

## 2.2 封装复杂的条件判断

**避免** 条件判断中包含过多的表达式和布尔运算。

**应用** 将条件判断提取成方法。

**原因** 要进行复杂的前置准备才能让代码在执行时进入某一条期望的分支路径。

## 2.3 提供 builder 方便复杂对象的构造

## 2.4 编写短小的方法

**尽量** 保证方法的长度不超过 20 行。

## 2.5 编写短小的类

**尽量** 保证类的长度不超过 200 行。

# 3. 保证可读性

代码命名和相关文档可以让被测代码理解起来更容易。

## 3.1 方法签名应当表达准确

**应当** 为方法提供准确的名字（建议使用动词开头）描述方法的作用，方法参数也应当有清晰的名字说明参数的作用。

## 3.2 建议公共元素提供 JavaDoc

**尽量** 在编写公共元素（类、接口、方法、常量、成员变量、枚举等）代码的同时编写 JavaDoc。JavaDoc 应遵循相应规范，重要的元素必须说明。

## 3.3 对外提供的接口应当提供文档和代码示例

**应当** 为对外提供的接口编写完善的文档，文档格式依照相关约定（如 Markdown、JavaDoc 等）。

**尽量** 为对外提供的接口编写示例（建议以测试用例的形式提供）。
