# Q & A

1. 单元测试量大之后会不会改动比较困难？

   - **允许对测试用例本身的修改**，但前提是相关的业务需求和设计目标发生无法兼容的变化时才可以修改。这种修改一次不会影响太多测试用例。

   - 测试代码和实现代码都应该及时重构，**避免一些代码坏味道造成“散弹式修改”**。常见的坏味道包括但不限于：

     - 魔数（硬编码的字面值），应该提取常量
     - 重复代码，应该提取方法
     - 通过反射调用的代码，应该避免

   - **Mock 设置的预期行为需要特别留意**，一旦真实行为发生变化，Mock 的行为也要相应调整。可以通过以下手段进行改善：

     -  如果可能，尽量不要使用 Mock
     - 将 Mock 设置的重复代码进行提取并放在一起，方便查找
     - Mock 设置的更多是接口的方法或者抽象方法，抽象方法的行为相对更加稳定，变化的可能性相对低一些

   - 在实现时遵循一些原则和模式，尤其是面向对象的**开闭原则**；在修改时尽可能**用扩展的方式增加代码而不是直接改动代码**。

   -  修改如果不可避免，也可以采用一些手段减少修改时的人为错误。如：
     - **结对**修改
     - 尽可能使用工具提供的**自动重构**功能

2. 如何确定单元测试覆盖是否足够？

   - 如果**严格遵守测试先行的方式来进行 TDD**，所有实现代码应该都是为了满足测试的要求而编写的，因此测试的覆盖是足够满足设计需要的。

   - 利用**代码覆盖率**的统计工具，可以得知在**测试执行过程中哪些代码没有被覆盖**。对这部分没有被覆盖到的代码进行分析，确定有覆盖必要之后补充测试。

   - 在测试用例的设计中，**留意参数（测试数据）和返回/副作用（测试结果）的类型**，根据这些类型找出必须覆盖的取值，一般常见的思路有**边界值和等价类**。在设计时也应充分考虑业务，**寻找业务范围内的有意义的取值**。

     > 如两位递增的版本号虽用整形表示，但业务上允许的范围是 00~99

     上述取值的覆盖还需**通过代码检视来确认**。

3. 单元测试的性能会不会太差？

   - 单元测试中 **不应该出现（或极少出现）涉及到 IO 或者异步的代码调用**，更多使用的是 Mock。这样即便是数量庞大，执行也能在数（十）秒内完成。
   - 如果测试中有涉及到 IO 或者异步的代码调用（这属于集成测试范围），应该**设置好测试用例的超时时间**。
   - 执行时间比较长的测试案例或测试类应该**用合理的命名，或是用 Category 以及 Suite 区分**。在测试执行时可以分组并行（要求测试用例**可以独立执行不不干扰**）执行，优化执行时间。

4. 比较复杂的数据准备或者断言代码（比如大量的集合创建和断言）如何提升编写效率？

   - 引入一些第三方库（如 Guava，https://github.com/google/guava ）或者自己编写一些 Builder 来创建复杂对象，并尽可能复用这些创建代码。但第一次编写 Builder 的成本是少不了的。
   - 建议使用 assertj(https://joel-costigliola.github.io/assertj/) 实现断言。一些比较复杂的对象都有丰富的断言方法。
